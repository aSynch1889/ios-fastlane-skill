require 'json'
require 'dotenv'

# iOS fastlane template generated by ios-fastlane-skill
default_platform(:ios)

base_env_path = File.expand_path(".env.fastlane", __dir__)
Dotenv.overload(base_env_path) if File.exist?(base_env_path)

platform :ios do
  PROJECT_NAME = "{{PROJECT_NAME}}"
  PROJECT_TARGET = ENV["FL_TARGET"] || "{{PROJECT_NAME}}"
  PROJECT_ROOT = File.expand_path("..", __dir__)

  WORKSPACE_INPUT = "{{WORKSPACE}}"
  XCODEPROJ_INPUT = "{{XCODEPROJ}}"
  WORKSPACE = WORKSPACE_INPUT.to_s.empty? ? "" : File.expand_path(WORKSPACE_INPUT, PROJECT_ROOT)
  XCODEPROJ = XCODEPROJ_INPUT.to_s.empty? ? "" : File.expand_path(XCODEPROJ_INPUT, PROJECT_ROOT)
  SCHEME_DEV = "{{SCHEME_DEV}}"
  SCHEME_DIS = "{{SCHEME_DIS}}"

  BUNDLE_ID_DEV = "{{BUNDLE_ID_DEV}}"
  BUNDLE_ID_DIS = "{{BUNDLE_ID_DIS}}"

  OUTPUT_DIR = File.expand_path("builds", __dir__)

  TEAM_ID = "{{TEAM_ID}}"
  PROFILE_DEV = "{{PROFILE_DEV}}"
  PROFILE_DIS = "{{PROFILE_DIS}}"
  SIGNING_STYLE = "{{SIGNING_STYLE}}" # automatic | manual

  MATCH_GIT_URL = ENV["MATCH_GIT_URL"] || "{{MATCH_GIT_URL}}"
  MATCH_GIT_BRANCH = ENV["MATCH_GIT_BRANCH"] || "{{MATCH_GIT_BRANCH}}"

  ENABLE_QUALITY_GATE = ENV["ENABLE_QUALITY_GATE"] || "{{ENABLE_QUALITY_GATE}}"
  ENABLE_TESTS = ENV["ENABLE_TESTS"] || "{{ENABLE_TESTS}}"
  ENABLE_SWIFTLINT = ENV["ENABLE_SWIFTLINT"] || "{{ENABLE_SWIFTLINT}}"

  ENABLE_SLACK_NOTIFY = ENV["ENABLE_SLACK_NOTIFY"] || "{{ENABLE_SLACK_NOTIFY}}"
  ENABLE_WECHAT_NOTIFY = ENV["ENABLE_WECHAT_NOTIFY"] || "{{ENABLE_WECHAT_NOTIFY}}"
  SLACK_WEBHOOK_URL = ENV["SLACK_WEBHOOK_URL"] || ""
  WECHAT_WEBHOOK_URL = ENV["WECHAT_WEBHOOK_URL"] || ""

  APP_STORE_CONNECT_API_KEY_PATH = ENV["APP_STORE_CONNECT_API_KEY_PATH"] || ""
  TESTFLIGHT_GROUPS = ENV["TESTFLIGHT_GROUPS"] || ""
  METADATA_PATH_INPUT = ENV["METADATA_PATH"] || "{{METADATA_PATH}}"
  METADATA_PATH = METADATA_PATH_INPUT.to_s.empty? ? "" : File.expand_path(METADATA_PATH_INPUT, PROJECT_ROOT)
  ENABLE_METADATA_UPLOAD = ENV["ENABLE_METADATA_UPLOAD"] || "{{ENABLE_METADATA_UPLOAD}}"
  ENABLE_SCREENSHOT_UPLOAD = ENV["ENABLE_SCREENSHOT_UPLOAD"] || "{{ENABLE_SCREENSHOT_UPLOAD}}"
  ENABLE_SNAPSHOT = ENV["ENABLE_SNAPSHOT"] || "{{ENABLE_SNAPSHOT}}"
  SNAPSHOT_SCHEME = ENV["SNAPSHOT_SCHEME"] || "{{SNAPSHOT_SCHEME}}"
  SNAPSHOT_DEVICES = ENV["SNAPSHOT_DEVICES"] || "{{SNAPSHOT_DEVICES}}"
  SNAPSHOT_LANGUAGES = ENV["SNAPSHOT_LANGUAGES"] || "{{SNAPSHOT_LANGUAGES}}"

  GYM_SKIP_CLEAN = ENV["GYM_SKIP_CLEAN"] || "{{GYM_SKIP_CLEAN}}"
  DERIVED_DATA_PATH = ENV["DERIVED_DATA_PATH"] || "{{DERIVED_DATA_PATH}}"
  CI_BUNDLE_INSTALL = ENV["CI_BUNDLE_INSTALL"] || "{{CI_BUNDLE_INSTALL}}"
  CI_COCOAPODS_DEPLOYMENT = ENV["CI_COCOAPODS_DEPLOYMENT"] || "{{CI_COCOAPODS_DEPLOYMENT}}"
  ENABLE_ARTIFACT_MANIFEST = ENV["ENABLE_ARTIFACT_MANIFEST"] || "true"

  PGYER_APP_URL = ENV["PGYER_APP_URL"] || ""

  @lane_started_at = {}

  def send_notification(title, message, sound = "default")
    safe_title = title.to_s.gsub('"', '\\"')
    safe_message = message.to_s.gsub('"', '\\"').gsub("\n", " ")
    safe_sound = sound.to_s.gsub('"', '\\"')
    script = "display notification \"#{safe_message}\" with title \"#{safe_title}\" sound name \"#{safe_sound}\""

    sh("osascript", "-e", script)
  rescue
    UI.important("macOS notification skipped")
  end

  def bool_true?(value)
    value.to_s.downcase == "true"
  end

  def pgyer_api_key
    ENV["PGYER_API_KEY"].to_s
  end

  def env_fetch(key, default_value)
    value = ENV[key]
    value.to_s.empty? ? default_value : value
  end

  def valid_team_id?(team_id)
    !team_id.to_s.empty? && team_id != "YOUR_TEAM_ID"
  end

  def manual_signing?
    SIGNING_STYLE.to_s.downcase == "manual"
  end

  def match_configured?
    !MATCH_GIT_URL.to_s.empty? && MATCH_GIT_URL != "YOUR_MATCH_GIT_URL"
  end

  def cert_for_export_method(method)
    method == "development" ? "Apple Development" : "Apple Distribution"
  end

  def app_store_connect_auth_options
    return {} if APP_STORE_CONNECT_API_KEY_PATH.to_s.empty?
    return {} unless File.exist?(APP_STORE_CONNECT_API_KEY_PATH)

    { api_key_path: APP_STORE_CONNECT_API_KEY_PATH }
  end

  def parse_csv(value)
    value.to_s.split(",").map(&:strip).reject(&:empty?)
  end

  def gym_container_options
    if !WORKSPACE.to_s.empty? && File.exist?(WORKSPACE)
      { workspace: WORKSPACE }
    elsif !XCODEPROJ.to_s.empty? && File.exist?(XCODEPROJ)
      { project: XCODEPROJ }
    else
      UI.user_error!("Neither WORKSPACE nor XCODEPROJ exists. Please check generated config.")
    end
  end

  def gym_performance_options
    options = {
      clean: !bool_true?(GYM_SKIP_CLEAN)
    }
    options[:derived_data_path] = DERIVED_DATA_PATH unless DERIVED_DATA_PATH.to_s.empty?
    options
  end

  def build_export_options(method:, bundle_id:, profile_name:, team_id:, signing_style:)
    style = signing_style.to_s.downcase
    options = {
      method: method,
      compileBitcode: false,
      signingStyle: style
    }

    options[:teamID] = team_id if valid_team_id?(team_id)

    if style == "manual"
      if profile_name.to_s.empty?
        UI.user_error!("Manual signing requires provisioning profile for #{bundle_id}")
      end
      options[:provisioningProfiles] = { bundle_id => profile_name }
      options[:signingCertificate] = cert_for_export_method(method)
    end

    options
  end

  def quality_gate_enabled?
    bool_true?(ENABLE_QUALITY_GATE)
  end

  def installed_codesign_identities
    output = sh("security find-identity -v -p codesigning 2>/dev/null || true")
    lines = output.to_s.split("\n")
    lines.select { |l| l.include?("Apple Development") || l.include?("iOS Development") || l.include?("Apple Distribution") || l.include?("iPhone Distribution") }
  rescue
    []
  end

  def ensure_codesigning_ready!
    return unless installed_codesign_identities.empty?
    UI.user_error!("No local code signing identities found. Install Apple Development/Distribution certificates with private keys, or configure match signing in .env.fastlane.")
  end

  def latest_fastlane_log
    candidates = Dir[File.expand_path("~/Library/Logs/fastlane/*.log")]
    return "" if candidates.empty?
    candidates.max_by { |f| File.mtime(f) }
  rescue
    ""
  end

  private_lane :load_env_layer do |options|
    env_name = options[:name]
    path = File.expand_path(".env.fastlane.#{env_name}", __dir__)

    if File.exist?(path)
      Dotenv.overload(path)
      UI.message("Loaded env layer: #{path}")
    else
      UI.important("Env layer not found: #{path}, using defaults")
    end
  end

  private_lane :resolve_env_build_options do |options|
    env_name = options[:env_name].to_s
    up = env_name.upcase
    defaults = options[:defaults] || {}

    {
      scheme: env_fetch("#{up}_SCHEME", defaults[:scheme]),
      bundle_id: env_fetch("#{up}_BUNDLE_ID", defaults[:bundle_id]),
      profile_name: env_fetch("#{up}_PROFILE", defaults[:profile_name]),
      export_method: env_fetch("#{up}_EXPORT_METHOD", defaults[:export_method]),
      configuration: env_fetch("#{up}_CONFIGURATION", defaults[:configuration]),
      upload_pgyer: env_fetch("#{up}_UPLOAD_PGYER", defaults[:upload_pgyer])
    }
  end

  private_lane :notify_channels do |options|
    lane_name = options[:lane] || "unknown"
    status = options[:status] || "info"
    version = options[:version] || "-"
    build = options[:build] || "-"
    commit = options[:commit] || "-"
    message = options[:message] || ""

    text = "[#{PROJECT_NAME}] lane=#{lane_name} status=#{status} version=#{version}(#{build}) commit=#{commit} #{message}"

    if bool_true?(ENABLE_SLACK_NOTIFY) && !SLACK_WEBHOOK_URL.to_s.empty?
      begin
        slack(
          slack_url: SLACK_WEBHOOK_URL,
          message: text,
          success: status == "success"
        )
      rescue => e
        UI.important("Slack notify failed: #{e.message}")
      end
    end

    if bool_true?(ENABLE_WECHAT_NOTIFY) && !WECHAT_WEBHOOK_URL.to_s.empty?
      begin
        payload = { msgtype: "text", text: { content: text } }
        sh("curl -sS -X POST '#{WECHAT_WEBHOOK_URL}' -H 'Content-Type: application/json' -d '#{payload.to_json}' >/dev/null")
      rescue => e
        UI.important("WeChat notify failed: #{e.message}")
      end
    end
  end

  private_lane :run_quality_gate do |options|
    unless quality_gate_enabled?
      UI.message("Quality gate disabled by ENABLE_QUALITY_GATE=false")
      next
    end

    scheme = options[:scheme] || SCHEME_DEV

    if bool_true?(ENABLE_TESTS)
      scan(
        **gym_container_options,
        scheme: scheme,
        clean: true,
        fail_build: true
      )
    end

    if bool_true?(ENABLE_SWIFTLINT)
      has_swiftlint = sh("command -v swiftlint >/dev/null 2>&1 && echo yes || echo no").strip == "yes"
      if has_swiftlint
        sh("swiftlint")
      else
        UI.important("swiftlint not installed, skipping lint step")
      end
    end
  end

  def extract_tag_build_number(tag)
    m = tag.to_s.match(/(\d+)$/)
    return nil unless m
    m[1]
  end

  private_lane :resolve_version_info do |options|
    build_number = options[:build_number]
    from_tag = bool_true?(options[:from_tag])

    if build_number.to_s.empty? && from_tag
      begin
        latest_tag = sh("git describe --tags --abbrev=0").strip
        build_number = extract_tag_build_number(latest_tag)
        UI.important("No numeric suffix found in tag #{latest_tag}, fallback to commit count") if build_number.to_s.empty?
      rescue
        UI.important("Tag lookup failed, fallback to commit count")
      end
    end

    if build_number.to_s.empty?
      begin
        build_number = sh("git rev-list --count HEAD").strip
      rescue
        build_number = Time.now.strftime("%y%m%d%H%M")
      end
    end

    increment_build_number(
      xcodeproj: XCODEPROJ,
      build_number: build_number
    )

    version = get_version_number(
      xcodeproj: XCODEPROJ,
      target: PROJECT_TARGET
    )
    build = get_build_number(xcodeproj: XCODEPROJ)

    commit = "unknown"
    changelog = "No changelog"
    changes = []
    begin
      commit = sh("git rev-parse --short HEAD").strip
      changelog = sh("git log -1 --pretty=%s").strip
      changes = sh("git log -10 --pretty=format:'- %h %s'").split("\n")
    rescue
      UI.important("Git metadata unavailable, changelog fallback applied")
    end

    {
      version: version,
      build: build,
      commit: commit,
      changelog: changelog,
      changes: changes
    }
  end

  private_lane :write_changelog_markdown do |options|
    env_type = options[:env_type]
    meta = options[:meta]

    FileUtils.mkdir_p(OUTPUT_DIR)
    path = File.join(OUTPUT_DIR, "CHANGELOG_#{env_type}_#{meta[:version]}_#{meta[:build]}.md")

    body = []
    body << "# #{PROJECT_NAME} #{env_type}"
    body << ""
    body << "- Version: #{meta[:version]}"
    body << "- Build: #{meta[:build]}"
    body << "- Commit: #{meta[:commit]}"
    body << "- Time: #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}"
    body << ""
    body << "## Summary"
    body << meta[:changelog].to_s
    body << ""
    body << "## Recent Commits"

    if meta[:changes].nil? || meta[:changes].empty?
      body << "- (No git history available)"
    else
      body.concat(meta[:changes])
    end

    File.write(path, body.join("\n"))
    path
  end

  private_lane :write_artifact_manifest do |options|
    return unless bool_true?(ENABLE_ARTIFACT_MANIFEST)

    lane_name = options[:lane].to_s
    status = options[:status].to_s
    duration_seconds = options[:duration_seconds]

    FileUtils.mkdir_p(OUTPUT_DIR)
    timestamp = Time.now.strftime("%Y%m%d%H%M%S")
    path = File.join(OUTPUT_DIR, "ARTIFACT_MANIFEST_#{lane_name}_#{timestamp}.json")

    artifacts = Dir[File.join(OUTPUT_DIR, "*")].select { |f| File.file?(f) }
    payload = {
      project: PROJECT_NAME,
      lane: lane_name,
      status: status,
      duration_seconds: duration_seconds,
      generated_at: Time.now.strftime('%Y-%m-%d %H:%M:%S'),
      artifacts: artifacts.map { |f| { file: File.basename(f), size_bytes: File.size(f) } }
    }

    File.write(path, JSON.pretty_generate(payload))
    path
  rescue => e
    UI.important("write_artifact_manifest failed: #{e.message}")
    ""
  end

  private_lane :build_ipa do |options|
    env_type = options[:env_type]
    scheme = options[:scheme]
    configuration = options[:configuration]
    export_method = options[:export_method]
    bundle_id = options[:bundle_id]
    profile_name = options[:profile_name]

    run_quality_gate(scheme: scheme)
    meta = resolve_version_info(
      build_number: options[:build_number],
      from_tag: options[:from_tag]
    )

    started = Time.now
    ensure_codesigning_ready!

    gym_options = {
      **gym_container_options,
      **gym_performance_options,
      scheme: scheme,
      configuration: configuration,
      export_method: export_method,
      output_directory: OUTPUT_DIR,
      output_name: "#{PROJECT_NAME}_#{env_type.capitalize}_#{meta[:version]}_#{meta[:build]}.ipa",
      export_options: build_export_options(
        method: export_method,
        bundle_id: bundle_id,
        profile_name: profile_name,
        team_id: TEAM_ID,
        signing_style: SIGNING_STYLE
      ),
      skip_package_ipa: false,
      skip_archive: false,
      include_bitcode: false
    }

    unless manual_signing?
      # Let xcodebuild fetch/manage provisioning profiles for automatic signing flows.
      gym_options[:xcargs] = "-allowProvisioningUpdates -allowProvisioningDeviceRegistration"
    end

    ipa_path = gym(gym_options)

    duration_seconds = (Time.now - started).round(1)
    ipa_size_mb = (File.size(ipa_path).to_f / 1024 / 1024).round(2)

    changelog_path = write_changelog_markdown(env_type: env_type, meta: meta)
    meta.merge(
      {
        ipa_path: ipa_path,
        changelog_path: changelog_path,
        duration_seconds: duration_seconds,
        ipa_size_mb: ipa_size_mb
      }
    )
  end

  private_lane :build_and_upload_pgyer do |options|
    meta = build_ipa(options)

    upload_to_pgyer(
      env_type: options[:env_type],
      version: meta[:version],
      build: meta[:build],
      changelog: meta[:changelog],
      ipa_path: meta[:ipa_path]
    )

    link_text = PGYER_APP_URL.to_s.empty? ? "" : " link=#{PGYER_APP_URL}"

    notify_channels(
      lane: options[:env_type],
      status: "success",
      version: meta[:version],
      build: meta[:build],
      commit: meta[:commit],
      message: "uploaded_to=pgyer duration=#{meta[:duration_seconds]}s size=#{meta[:ipa_size_mb]}MB changelog=#{File.basename(meta[:changelog_path])}#{link_text}"
    )

    send_notification(
      "#{options[:env_type].to_s.upcase}打包完成",
      "#{PROJECT_NAME} #{meta[:version]}(#{meta[:build]}) #{meta[:duration_seconds]}s #{meta[:ipa_size_mb]}MB",
      "Glass"
    )

    meta
  end

  before_all do |lane, _options|
    @lane_started_at[lane.to_s] = Time.now
    begin
      xcode_ver = sh("xcodebuild -version | head -n1").strip
      UI.message("Environment check: #{xcode_ver}")
    rescue
      UI.important("xcodebuild not available in PATH")
    end
  end

  after_all do |lane, _options|
    started = @lane_started_at[lane.to_s]
    duration = started ? (Time.now - started).round(1) : nil
    manifest_path = write_artifact_manifest(lane: lane, status: "success", duration_seconds: duration)

    UI.message("Lane #{lane} finished in #{duration}s") if duration
    UI.message("Artifact manifest: #{manifest_path}") unless manifest_path.to_s.empty?
  end

  desc "准备构建环境"
  lane :prepare do
    if File.exist?("Podfile")
      cocoapods(
        clean_install: true,
        repo_update: false
      )
    else
      UI.message("No Podfile found, skip cocoapods in prepare lane")
    end
  end

  desc "质量门禁（测试+可选 SwiftLint）"
  lane :quality_gate do |options|
    run_quality_gate(scheme: options[:scheme] || SCHEME_DEV)
  end

  desc "版本策略：支持 build_number、from_tag 或 commit_count"
  lane :versioning do |options|
    resolve_version_info(
      build_number: options[:build_number],
      from_tag: options[:from_tag]
    )
  end

  desc "签名同步（match）"
  lane :certificates do |options|
    unless manual_signing?
      UI.message("Automatic signing enabled, skip match")
      next
    end

    unless match_configured?
      UI.important("MATCH_GIT_URL not set, skip match. Configure it in .env.fastlane(.ci) when needed.")
      next
    end

    type = options[:type] || "development"
    readonly = options.key?(:readonly) ? options[:readonly] : false

    match_options = {
      type: type,
      readonly: readonly,
      git_url: MATCH_GIT_URL,
      git_branch: MATCH_GIT_BRANCH,
      app_identifier: [BUNDLE_ID_DEV, BUNDLE_ID_DIS].uniq
    }
    match_options[:team_id] = TEAM_ID if valid_team_id?(TEAM_ID)

    match(match_options)
  end

  desc "同步多类型 profile（development/adhoc/appstore）"
  lane :profiles do |options|
    readonly = options.key?(:readonly) ? options[:readonly] : false
    %w[development adhoc appstore].each do |type|
      certificates(type: type, readonly: readonly)
    end
  end

  desc "本地 Dev 打包（支持 DEV_* env 覆盖）"
  lane :dev do
    prepare
    opts = resolve_env_build_options(
      env_name: "dev",
      defaults: {
        scheme: SCHEME_DEV,
        bundle_id: BUNDLE_ID_DEV,
        profile_name: PROFILE_DEV,
        export_method: "development",
        configuration: "Debug",
        upload_pgyer: "true"
      }
    )

    certificates(type: opts[:export_method] == "development" ? "development" : "adhoc", readonly: false)

    if bool_true?(opts[:upload_pgyer])
      build_and_upload_pgyer(
        env_type: "dev",
        scheme: opts[:scheme],
        configuration: opts[:configuration],
        export_method: opts[:export_method],
        bundle_id: opts[:bundle_id],
        profile_name: opts[:profile_name]
      )
    else
      build_ipa(
        env_type: "dev",
        scheme: opts[:scheme],
        configuration: opts[:configuration],
        export_method: opts[:export_method],
        bundle_id: opts[:bundle_id],
        profile_name: opts[:profile_name]
      )
    end
  end

  desc "本地 Dis 打包（支持 DIS_* env 覆盖）"
  lane :dis do
    prepare
    opts = resolve_env_build_options(
      env_name: "dis",
      defaults: {
        scheme: SCHEME_DIS,
        bundle_id: BUNDLE_ID_DIS,
        profile_name: PROFILE_DIS,
        export_method: "ad-hoc",
        configuration: "Release",
        upload_pgyer: "true"
      }
    )

    certificates(type: opts[:export_method] == "app-store" ? "appstore" : "adhoc", readonly: false)

    if bool_true?(opts[:upload_pgyer])
      build_and_upload_pgyer(
        env_type: "dis",
        scheme: opts[:scheme],
        configuration: opts[:configuration],
        export_method: opts[:export_method],
        bundle_id: opts[:bundle_id],
        profile_name: opts[:profile_name]
      )
    else
      build_ipa(
        env_type: "dis",
        scheme: opts[:scheme],
        configuration: opts[:configuration],
        export_method: opts[:export_method],
        bundle_id: opts[:bundle_id],
        profile_name: opts[:profile_name]
      )
    end
  end

  desc "多环境 Staging 打包（读取 fastlane/.env.fastlane.staging）"
  lane :staging do
    prepare
    load_env_layer(name: "staging")
    opts = resolve_env_build_options(
      env_name: "staging",
      defaults: {
        scheme: SCHEME_DIS,
        bundle_id: BUNDLE_ID_DIS,
        profile_name: PROFILE_DIS,
        export_method: "ad-hoc",
        configuration: "Release",
        upload_pgyer: "true"
      }
    )

    certificates(type: opts[:export_method] == "app-store" ? "appstore" : "adhoc", readonly: false)

    meta = build_ipa(
      env_type: "staging",
      scheme: opts[:scheme],
      configuration: opts[:configuration],
      export_method: opts[:export_method],
      bundle_id: opts[:bundle_id],
      profile_name: opts[:profile_name]
    )

    if bool_true?(opts[:upload_pgyer])
      upload_to_pgyer(
        env_type: "staging",
        version: meta[:version],
        build: meta[:build],
        changelog: meta[:changelog],
        ipa_path: meta[:ipa_path]
      )
    end

    notify_channels(
      lane: "staging",
      status: "success",
      version: meta[:version],
      build: meta[:build],
      commit: meta[:commit],
      message: "uploaded_to=#{bool_true?(opts[:upload_pgyer]) ? 'pgyer' : 'none'} duration=#{meta[:duration_seconds]}s size=#{meta[:ipa_size_mb]}MB changelog=#{File.basename(meta[:changelog_path])}"
    )
  end

  desc "多环境 Prod 打包（读取 fastlane/.env.fastlane.prod）"
  lane :prod do
    prepare
    load_env_layer(name: "prod")
    opts = resolve_env_build_options(
      env_name: "prod",
      defaults: {
        scheme: SCHEME_DIS,
        bundle_id: BUNDLE_ID_DIS,
        profile_name: PROFILE_DIS,
        export_method: "app-store",
        configuration: "Release",
        upload_pgyer: "false"
      }
    )

    certificates(type: opts[:export_method] == "app-store" ? "appstore" : "adhoc", readonly: false)

    meta = build_ipa(
      env_type: "prod",
      scheme: opts[:scheme],
      configuration: opts[:configuration],
      export_method: opts[:export_method],
      bundle_id: opts[:bundle_id],
      profile_name: opts[:profile_name]
    )

    if bool_true?(opts[:upload_pgyer])
      upload_to_pgyer(
        env_type: "prod",
        version: meta[:version],
        build: meta[:build],
        changelog: meta[:changelog],
        ipa_path: meta[:ipa_path]
      )
    end

    notify_channels(
      lane: "prod",
      status: "success",
      version: meta[:version],
      build: meta[:build],
      commit: meta[:commit],
      message: "uploaded_to=#{bool_true?(opts[:upload_pgyer]) ? 'pgyer' : 'none'} duration=#{meta[:duration_seconds]}s size=#{meta[:ipa_size_mb]}MB changelog=#{File.basename(meta[:changelog_path])}"
    )
  end

  desc "发布到 TestFlight"
  lane :release_testflight do
    prepare
    certificates(type: "appstore", readonly: false)

    meta = build_ipa(
      env_type: "testflight",
      scheme: SCHEME_DIS,
      configuration: "Release",
      export_method: "app-store",
      bundle_id: BUNDLE_ID_DIS,
      profile_name: PROFILE_DIS
    )

    tf_options = app_store_connect_auth_options.merge(
      app_identifier: BUNDLE_ID_DIS,
      ipa: meta[:ipa_path],
      skip_waiting_for_build_processing: true,
      changelog: meta[:changelog]
    )
    tf_options[:groups] = TESTFLIGHT_GROUPS.split(",").map(&:strip).reject(&:empty?) unless TESTFLIGHT_GROUPS.to_s.empty?

    pilot(tf_options)

    notify_channels(
      lane: "release_testflight",
      status: "success",
      version: meta[:version],
      build: meta[:build],
      commit: meta[:commit],
      message: "uploaded_to=testflight duration=#{meta[:duration_seconds]}s size=#{meta[:ipa_size_mb]}MB changelog=#{File.basename(meta[:changelog_path])}"
    )
  end

  desc "自动截图（snapshot）"
  lane :snapshot_capture do |options|
    unless bool_true?(ENABLE_SNAPSHOT)
      UI.important("ENABLE_SNAPSHOT=false, skip snapshot capture")
      next
    end

    scheme = options[:scheme] || SNAPSHOT_SCHEME || SCHEME_DIS
    devices = parse_csv(options[:devices] || SNAPSHOT_DEVICES)
    languages = parse_csv(options[:languages] || SNAPSHOT_LANGUAGES)

    snap_options = app_store_connect_auth_options.merge(
      **gym_container_options,
      scheme: scheme,
      clean: !bool_true?(GYM_SKIP_CLEAN)
    )
    snap_options[:devices] = devices unless devices.empty?
    snap_options[:languages] = languages unless languages.empty?

    snapshot(snap_options)
  end

  desc "仅同步 metadata / screenshots（不上传二进制）"
  lane :metadata_sync do
    unless bool_true?(ENABLE_METADATA_UPLOAD) || bool_true?(ENABLE_SCREENSHOT_UPLOAD)
      UI.important("Both ENABLE_METADATA_UPLOAD and ENABLE_SCREENSHOT_UPLOAD are false, skip metadata_sync")
      next
    end

    deliver(
      **app_store_connect_auth_options,
      app_identifier: BUNDLE_ID_DIS,
      force: true,
      skip_binary_upload: true,
      metadata_path: METADATA_PATH,
      skip_metadata: !bool_true?(ENABLE_METADATA_UPLOAD),
      skip_screenshots: !bool_true?(ENABLE_SCREENSHOT_UPLOAD),
      submit_for_review: false,
      automatic_release: false
    )
  end

  desc "发布到 App Store Connect（不自动提交审核）"
  lane :release_appstore do
    prepare
    certificates(type: "appstore", readonly: false)

    meta = build_ipa(
      env_type: "appstore",
      scheme: SCHEME_DIS,
      configuration: "Release",
      export_method: "app-store",
      bundle_id: BUNDLE_ID_DIS,
      profile_name: PROFILE_DIS
    )

    deliver(
      **app_store_connect_auth_options,
      app_identifier: BUNDLE_ID_DIS,
      ipa: meta[:ipa_path],
      force: true,
      submit_for_review: false,
      automatic_release: false,
      metadata_path: METADATA_PATH,
      skip_metadata: !bool_true?(ENABLE_METADATA_UPLOAD),
      skip_screenshots: !bool_true?(ENABLE_SCREENSHOT_UPLOAD)
    )

    notify_channels(
      lane: "release_appstore",
      status: "success",
      version: meta[:version],
      build: meta[:build],
      commit: meta[:commit],
      message: "uploaded_to=appstore_connect duration=#{meta[:duration_seconds]}s size=#{meta[:ipa_size_mb]}MB changelog=#{File.basename(meta[:changelog_path])}"
    )
  end

  desc "CI 初始化（setup_ci + bundle + pods）"
  lane :ci_setup do
    setup_ci if is_ci

    if bool_true?(CI_BUNDLE_INSTALL)
      sh("bundle check || bundle install --path vendor/bundle")
    end

    if File.exist?("Podfile")
      cocoapods(
        clean_install: true,
        repo_update: false,
        silent: true,
        deployment: bool_true?(CI_COCOAPODS_DEPLOYMENT)
      )
    else
      UI.message("No Podfile found, skip cocoapods in ci_setup lane")
    end
  end

  desc "CI Dev 构建并上传蒲公英"
  lane :ci_build_dev do
    ci_setup
    certificates(type: "development", readonly: true)

    build_and_upload_pgyer(
      env_type: "dev",
      scheme: SCHEME_DEV,
      configuration: "Debug",
      export_method: "development",
      bundle_id: BUNDLE_ID_DEV,
      profile_name: PROFILE_DEV
    )
  end

  desc "CI Dis 构建并上传蒲公英"
  lane :ci_build_dis do
    ci_setup
    certificates(type: "adhoc", readonly: true)

    build_and_upload_pgyer(
      env_type: "dis",
      scheme: SCHEME_DIS,
      configuration: "Release",
      export_method: "ad-hoc",
      bundle_id: BUNDLE_ID_DIS,
      profile_name: PROFILE_DIS
    )
  end

  desc "检查关键配置"
  lane :validate_config do
    UI.user_error!("PGYER_API_KEY not configured") if pgyer_api_key.empty? || pgyer_api_key == "YOUR_PGYER_API_KEY"

    if manual_signing? && !match_configured?
      UI.important("Manual signing without match: ensure local certificates/profiles are installed")
    end

    if bool_true?(ENABLE_SLACK_NOTIFY) && SLACK_WEBHOOK_URL.to_s.empty?
      UI.important("ENABLE_SLACK_NOTIFY=true but SLACK_WEBHOOK_URL is empty")
    end

    if bool_true?(ENABLE_WECHAT_NOTIFY) && WECHAT_WEBHOOK_URL.to_s.empty?
      UI.important("ENABLE_WECHAT_NOTIFY=true but WECHAT_WEBHOOK_URL is empty")
    end

    if (bool_true?(ENABLE_METADATA_UPLOAD) || bool_true?(ENABLE_SCREENSHOT_UPLOAD)) && !File.directory?(METADATA_PATH)
      UI.important("metadata path does not exist: #{METADATA_PATH}")
    end

    UI.success("Config validation passed")
  end

  private_lane :upload_to_pgyer do |options|
    env_type = options[:env_type]
    version = options[:version]
    build = options[:build]
    changelog = options[:changelog]
    ipa_path = options[:ipa_path]

    unless ipa_path
      ipa_path = File.join(OUTPUT_DIR, "#{PROJECT_NAME}_#{env_type.capitalize}_#{version}_#{build}.ipa")
      ipa_path = File.expand_path(ipa_path) unless ipa_path.start_with?("/")
    end

    unless File.exist?(ipa_path)
      raise "找不到 IPA 文件: #{ipa_path}"
    end

    pgyer(
      api_key: pgyer_api_key,
      ipa: ipa_path,
      update_description: "#{env_type.upcase} 构建\\n版本: #{version}\\nBuild: #{build}\\n变更: #{changelog}\\n时间: #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}"
    )
  end

  desc "清理构建产物"
  lane :clean_builds do
    sh("rm -rf #{OUTPUT_DIR}/*")
    puts "clean finished"
  end

  error do |lane, exception|
    started = @lane_started_at[lane.to_s]
    duration = started ? (Time.now - started).round(1) : nil
    log_path = latest_fastlane_log
    manifest_path = write_artifact_manifest(lane: lane, status: "failed", duration_seconds: duration)

    short_msg = exception.message.to_s[0..200]
    notify_channels(
      lane: lane,
      status: "failed",
      message: "duration=#{duration}s log=#{log_path} manifest=#{manifest_path} error=#{short_msg}"
    )
    send_notification("打包失败", "#{lane}: #{short_msg}", "Basso")
  end
end
